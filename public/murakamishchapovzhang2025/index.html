<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Global Determinacy According to HANK | David Murakami</title>
<meta name="keywords" content="">
<meta name="description" content="We show that the tractable HANK model does not satisfy global determinacy, which we define as a model which is both locally determinate and with a unique MSV solution.">
<meta name="author" content="David Murakami, Ivan Shchapov, and Yifan Zhang">
<link rel="canonical" href="https://hirothreading.github.io/murakamishchapovzhang2025/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.470fff1cb9e2508f8866f6c66e84e786694bebe65a57e33c92fe27826fbfafc9.css" integrity="sha256-Rw//HLniUI&#43;IZvbGboTnhmlL6&#43;ZaV&#43;M8kv4ngm&#43;/r8k=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://hirothreading.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://hirothreading.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://hirothreading.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://hirothreading.github.io/apple-touch-icon.png">

<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://hirothreading.github.io/murakamishchapovzhang2025/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://hirothreading.github.io/murakamishchapovzhang2025/">
  <meta property="og:site_name" content="David Murakami">
  <meta property="og:title" content="Global Determinacy According to HANK">
  <meta property="og:description" content="We show that the tractable HANK model does not satisfy global determinacy, which we define as a model which is both locally determinate and with a unique MSV solution.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="research">
    <meta property="article:published_time" content="2025-05-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-11T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Global Determinacy According to HANK">
<meta name="twitter:description" content="We show that the tractable HANK model does not satisfy global determinacy, which we define as a model which is both locally determinate and with a unique MSV solution.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Research",
      "item": "https://hirothreading.github.io/research/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Global Determinacy According to HANK",
      "item": "https://hirothreading.github.io/murakamishchapovzhang2025/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Global Determinacy According to HANK",
  "name": "Global Determinacy According to HANK",
  "description": "We show that the tractable HANK model does not satisfy global determinacy, which we define as a model which is both locally determinate and with a unique MSV solution.",
  "keywords": [
    
  ],
  "articleBody": " Download: [TBA] Abstract A linear rational expectations model that satisfies the Blanchard-Kahn conditions is deemed as locally determinate. If this model also possesses a unique minimum state variable (MSV) solution, we term it as “globally determinate”. The canonical New Keynesian model subject to the effective lower bound (ELB) constraint does not generally possess a unique MSV solution unless monetary policy is passive; conversely violating local determinacy. This global indeterminacy problem stems from a strong feedback loop between expectations of endogenous variables and their current realisations at the ELB. This problem extends to a standard tractable heterogeneous agent New Keynesian (HANK) model. However, we show that global determinacy is restored under passive monetary policy and sufficiently limited asset market participation when “inverted aggregate demand logic” applies – further amplifying the “Catch-22 problem” in HANK models. Additionally, a standard HANK model with an active robust real rate rule fails to satisfy global determinacy conditions. But it is globally determinate with an inverted aggregate demand curve, much like the passive Taylor rule case.\nBlanchard-Kahn and Coherency-Completeness Regions for the NK Model with the ELB and Persistent Fiscal Policy ",
  "wordCount" : "185",
  "inLanguage": "en",
  "datePublished": "2025-05-11T00:00:00Z",
  "dateModified": "2025-05-11T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "David Murakami, Ivan Shchapov, and Yifan Zhang"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://hirothreading.github.io/murakamishchapovzhang2025/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "David Murakami",
    "logo": {
      "@type": "ImageObject",
      "url": "https://hirothreading.github.io/favicon.ico"
    }
  }
}
</script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
            {left: "\\begin{align}", right: "\\end{align}", display: true},
            {left: "\\begin{align*}", right: "\\end{align*}", display: true},
            {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
            {left: "\\begin{gather}", right: "\\end{gather}", display: true},
            {left: "\\begin{CD}", right: "\\end{CD}", display: true},
          ],
          
          throwOnError : false
        });
    });
</script>
 

</head>

<body class="" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://hirothreading.github.io/" accesskey="h" title="David Murakami">
             
                <img src="https://hirothreading.github.io/favicon.ico" alt="" aria-label="logo"
                    height="18"
                    width="18">David Murakami</a>
            <div class="logo-switches">
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://hirothreading.github.io/research/" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://hirothreading.github.io/courses/" title="Teaching">
                    <span>Teaching</span>
                </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Global Determinacy According to HANK
    </h1>

    
    <div class="post-meta"><span title='2025-05-11 00:00:00 +0000 UTC'>May 2025</span>&nbsp;&middot;&nbsp;David Murakami, Ivan Shchapov, and Yifan Zhang

</div>
  </header> 
  <div class="post-content"><hr>
<h4 id="download">Download:</h4>
<ul>
<li>[TBA]</li>
</ul>
<!-- - [Working paper]() -->
<hr>
<h4 id="abstract">Abstract</h4>
<p>A linear rational expectations model that satisfies the Blanchard-Kahn conditions is deemed as locally determinate. If this model also possesses a unique minimum state variable (MSV) solution, we term it as &ldquo;globally determinate&rdquo;. The canonical New Keynesian model subject to the effective lower bound (ELB) constraint does not generally possess a unique MSV solution unless monetary policy is passive; conversely violating local determinacy. This global indeterminacy problem stems from a strong feedback loop between expectations of endogenous variables and their current realisations at the ELB. This problem extends to a standard tractable heterogeneous agent New Keynesian (HANK) model. However, we show that global determinacy is restored under passive monetary policy and sufficiently limited asset market participation when &ldquo;inverted aggregate demand logic&rdquo; applies &ndash; further amplifying the &ldquo;Catch-22 problem&rdquo; in HANK models. Additionally, a standard HANK model with an active robust real rate rule fails to satisfy global determinacy conditions. But it is globally determinate with an inverted aggregate demand curve, much like the passive Taylor rule case.</p>
<hr>
<h4 id="blanchard-kahn-and-coherency-completeness-regions-for-the-nk-model-with-the-elb-and-persistent-fiscal-policy">Blanchard-Kahn and Coherency-Completeness Regions for the NK Model with the ELB and Persistent Fiscal Policy</h4>
<p><img loading="lazy" src="/global_det_iadl_tr.pdf"></p>
<!-- ---

#### Seminars and Presentations

---

#### Citation:
 -->

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>
</html>
